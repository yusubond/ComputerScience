## #3 CPU调度

### CPU调度

CPU调度是多道程序操作系统的基础，是指从就绪队列中选择进程并为止分配CPU的问题。进程执行由CPU执行和I/O等待周期组成，进程在这两个状态(**CPU区间** <---> **I/O区间**)间切换。**CPU约束进程**，是指进程中可能有少量长CPU区间；而 **I/O约束进程**，是指进程中可能有很多短的CPU区间。_进程选择是由短期调度程序或CPU调度程序执行的_。

CPU调度的四种环境包括：

1）进程由运行状态--->等待状态；  
2）进程由运行状态--->就绪状态；  
3）进程由等待状态--->就绪状态；  
4）进程终止。

当进程只发生在1）和4）环境中时，称为 **非抢占式的**，其他情况称为 **抢占式的**。

### CPU调度算法

<b>调度准则</b>

为了比较各个CPU调度算法，通常有一些调度准则，包括：CPU使用率，吞吐量，周转时间，等待时间，响应时间等。

算法1：<font color="#0000ff">先到先服务算法</font> First-Come First-Served

先到先服务算法是最简单的CPU调度算法，算法允许先请求CPU的进程先分配到CPU(即，当一个进程进入到就绪队列，其PCB链接到队列的尾部)，这个策略可以采用FIFO队列实现。

FCFS调度算法是 <b>非抢占式的</b>。一旦CPU被分配给一个进程，该进程就会保持CPU直到释放CPU为止，即程序终止或请求I/O。

其特点是，通常情况下，其平均等待时间比较大(原因：CPU约束进程和I/O约束进程的先后顺序)。

算法2：<font color="#0000ff">最短作业优先调度</font> Shortest-Job First

SJF调度算法将每一个进程与其下一个CPU区间段相关联，优先选择具有最短CPU区间(下一个)的进程，通常用于长期调度程序。SJF调度算法可证明是 **最佳的**，因为其平均等待时间最小。其难点在于如何预测下一个CPU区间的长度，一般采用指数平均。设t_n为第n个CPU区间的长度，τ_n+1为下一个CPU区间的预测值。对于α(0≤α≤1)，定义`τ_n+1 = αt_n + (1-α)τ_n`。如果α=0，则τ_n+1 = τ_n，说明进来历史没有影响；如果α=1，则τ_n+1 = t_n，说明只有最近的CPU区间才重要。

SJF算法分为抢占式和非抢占式。当一个新进程到达就绪队列而当前进程正在执行，如果新进程的CPU区间的长度较短，则抢占当前进程，称为 **抢占的SJF算法**，又称为 **最短剩余时间调度**。

算法3：<font color="#0000ff">优先级调度算法</font>

每一个进程都有一个优先级与其关联，将具有最高优先级的进程分配到CPU。SJF算法可以看做简单的优先级算法。优先级调度算法可以是抢占的(新到达进程的优先级若高于当前运行进程，则直接抢占CPU)或非抢占的(新到达进程的优先级若高于当前进程，则加入就绪队列)。

优先级调度算法的一个主要问题是 **无限阻塞** 或 **饥饿**，是指低优先级的进程可能无穷等待CPU。这个问题的解决方法之一是 **老化技术** (逐渐增加在系统中等待很长时间的进程的优先级)。

算法4：<font color="#0000ff">轮转法调度</font>

轮转法(Round-Robin)调度算法是专门为分时系统设计的。其思想是，设置一个时间片，对就绪队列进行循环访问，并分配CPU。这个算法的问题是涉及到进程的上下文切换问题。值得注意的，时间片的分配一般为10-100ms，而上下文切换时间一般小于0.01ms。

算法5：<font color="#0000ff">多级队列调度</font>

多级队列调度是指将就绪队列分成多个独立队列，每个队列有自己的调度算法，队列也可以调度。

算法6：<font color="#0000ff">多级反馈队列调度</font>

多级反馈队列调度是最通用，最复杂的调度算法，其思想是根据反馈信息(CPU时间，优先级)允许进程在队列中转移。

### 多处理器调度

多处理器调度可以更好地利用多处理器的体系结构，同时也使负载均衡称为可能。一般，有两种方法可以实现多处理器调度：**非对称处理** (主处理器<--->从处理器)和 **对称处理** (各个处理器自我调度)。

对于 **对称处理** 存在处理器亲和性问题，即指一个进程对其运行所在的处理器的亲和性，避免进程在处理器间转移，确保缓存不失效。**软亲和性** 是指设法保持进程在同一个处理器，但不能做任何保证；**硬亲和性**，是指不允许进程在处理器间转移。

**负载均衡**，通常只是针对那些拥有自己私有的可执行进程的处理器而言的。其有两种方法可以实现：1）push migration(将进程推送到另一个处理器上) 和 2）pull migration(从另一个处理器上拿到进程)。

对称多线程技术，也称为超线程，是指由同一个物理处理器，提供多个逻辑处理器。

### 线程调度

线程调度问题，又称为用户线程和内核线程的调度问题。其存在两种竞争范围：**进程竞争范围** 和 **系统竞争范围**。**进程竞争范围**，指相同进程的线程之间发生竞争关系，主要存在多对一模型和多对多模型；**系统竞争范围**，指所有线程间存在竞争关系，主要是一对一模型。_Linux系统调度，仅使用系统竞争范围方法_。

在线程库的API中，`pthread_attr_setscope(pthread_attr_t *attr, int scope)`和`pthread_attr_getscope(pthread_attr_t *attr, int *scope)`两个函数与竞争范围相关。竞争范围可使用标志位`PTHREAD_SCOPE_SYSTEM`和`PTHREAD_SCOPE_PROCESS`。

### Linux调度实例

Linux调度程序是抢占的，基于优先级的算法，具有两个独立的优先级范围：0-99的real-time范围和100-140的nice范围。这两个范围映射到全局优先级，其中数值越小表明优先级越高。Linux系统给较高的优先级分配较长的时间片，给较低的优先级分配较小的时间片。另外，实时任务被分配 **静态优先级**，所有其他任务都具有 **动态优先级**。
