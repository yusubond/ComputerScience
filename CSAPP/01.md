# 深入理解计算机系统之并发编程

## 1.并发

最简单和最基本的并发，是指两个或两个以上 **独立** 的活动，**同时** 发生。计算机中并发的两种方式包括：**多核处理器的真正并行** 和 **单核处理器的任务切换**；其基本实现途径也有三种：**基于进程并发**，**基于I/O多路复用并发** 和 **基于线程并发**。通常，多进程并发具有以下优势：1）操作系统在进程间提供的附加保护操作和更高级别的通信机制，可以更容易编写安全的代码；2）可以使用远程连接的方式在不同的机器上运行独立的代码。

进程是由内核自动调度的，而且具有独立的虚拟内存空间，要实现数据共享，必须显式地IPC机制。事件驱动程序创建它们自己的并发逻辑流，逻辑流被模型化为状态机，用I/O多路复用来显式地调度这些逻辑流。因为程序运行在一个单一进程中，所以流之间共享数据速度很快而且容易。线程是这些方法的结合。同基于进程的流一样，线程也是有内核自动调度的。同基于I/O多路复用的流一样，线程是运行在一个单一进程的上下文中的，因此可以快速而方便的共享数据。

![concurrency](http://on64c9tla.bkt.clouddn.com/Comput/concurrency.png)

如上图所示，所有程序的集合能够被划分成不相交的顺序程序集合和并发程序集合。写顺序程序只有一条逻辑流，写并发程序有多条并发流。**并行程序是一个运行在多个处理器上的并发程序**。并行程序的集合是并发程序集合的真子集。

### 1.1基于进程的并发编程

服务器端在接收客户端连接请求之后，服务器派生一个子进程(子进程获得服务器描述符表的完整副本)。注意：**子进程关闭它的副本中的监听描述符，而父进程关闭已连接的描述符**。(因为父、子进程中的已连接描述符都指向同一个文件表表项，所以父进程关闭已连接描述符的副本至关重要。否则，将永远不会释放已连接描述符的文件表条目，而由此引起的内存泄漏将最终耗尽可用内存，是系统崩溃。)

![process-based-concurrency](http://on64c9tla.bkt.clouddn.com/Comput/process-based-concurrency.png)

优劣：1）父、子进程间共享状态信息，其模型是：共享文件表，但是不共享用户地址空间。进程有独立的地址空间，可避免一个进程覆盖另一个进程的虚拟内存。2）独立的地址空间使得进程共享状态信息变得困难。为了共享状态信息，必须使用显式的IPC机制。

### 1.2基于I/O多路复用的并发编程

I/O多路复用技术的基本思想是使用select函数，要求内核挂起进程，只有在一个或多个I/O事件发生后，才将控制返回给应用程序。

### 1.3基于线程的并发编程

线程同步就是当多个线程共享相同的内存时，当某个线程可以修改变量，而其他线程也可以读取或修改这个变量的时候，就需要对这些线程进行同步，以确保他们在访问变量的存储内容时不会访问到无效的数值。”，确保同步的措施是在操作前进行加锁。

**互斥锁**：通常提供互斥为目的的二元信号量称为互斥锁。在一个互斥锁上执行P操作称为对互斥锁加锁，执行V操作称为对互斥锁解锁。其关键思想是，**P操作和V操作的结合创建了一组状态，叫禁止区。** 对互斥量进行加锁后，任何其他试图再对该互斥量加锁的线程都会被阻塞直到当前持有锁的线程释放锁。

**互斥锁加锁解锁顺序规则**:给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的。

读写锁, “当读写锁是写加锁时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞。
当读写锁是读加锁时，在这个锁被解锁之前，所有试图以读模式对他进行加锁的线程都可以得到访问权”。

在并发线程中，多个线程需要对共享资源进行访问。一个线程利用信号量操作来通知另一个线程，程序状态中的某个条件是否为真。这种方式称为 *运用信号量调度共享资源*。两个经典的例子是 **生产者-消费者** 和 **读-写者** 问题。

**生产者-消费者** 问题

![product-consumer](http://on64c9tla.bkt.clouddn.com/Comput/product-consumer.png)

因为插入和取出项目都涉及更新共享变量，必须保证对缓冲区的访问是 **互斥的**，并且还需要 **调度** 缓冲区的访问。如果缓冲区是满状态，则生产者必须等待直到缓冲区变得有槽位可用；如果缓冲区是空的，那么消费者必须等待直到有一个项目变为可用。

**读-写者** 问题

读-写者问题是互斥问的一个概括。修改对象的线程称为 **写者**，只读取对象的线程称为 **读者**。**写者必须拥有对对象的独占访问，而读者可以与无限多个其他的读者共享对象**。

读写者问题的几个变种。1）读者优先。要求不让读者等待，除非已经把使用对象的权限赋予了一个写者。读者不会因为写者在等待而等待。**但是，可能会导致饥饿，即写者线程出现无线等待的情况**。2）写者优先。要求一旦一个写者准备好写操作，写者线程尽可能快地完成写操作。即在一个写者后到达的读者必须等待，即使写者也在等待。
